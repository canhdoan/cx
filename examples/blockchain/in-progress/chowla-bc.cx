package bc

var count i32
var limit i32
var c []bool
var power i32

func chowla(n i32) (out i32) {
    if n < 1 {
        out = -1
		return
    }
	
    var sum i32 = 0
	var c i32
	var i i32
	var j i32
    for i = 2; i*i <= n; i++ {
		c = i32.mod(n, i)
        if i32.eq(c, 0) {
            j = i32.div(n, i)
			
            if i32.eq(i, j){
                sum += i
            } else {
                sum += i + j
            }
        }
    }
	out = sum
}

 
func sieve(limit i32) (out []bool) {
    // True denotes composite, false denotes prime.
    // Only interested in odd numbers >= 3
    var c [limit]bool
	var i i32
	var j i32
	var ch i32
    for i = 3; i*3 < limit; i += 2 {
		ch = chowla(i)
        if c[i] == false && i32.eq(ch, 0) {
            for j = 3 * i; j < limit; j += 2 * i {
                c[j] = true
            }
        }
    }
	out = c
}

func showChowla() {
	var i i32
	var ch i32
	for i = 1; i <= 37; i++ {
		ch = chowla(i)
		s := str.concat("chowla(", i32.str(i))
		str.print(str.concat(s, str.concat(") = ", i32.str(ch))))
    }

	// initial global variables
    count = 1
	limit = 10000
    c = sieve(limit)
    power = 100
	
    for i = 3; i < limit; i += 2 {
        if c[i] == false {
            count++
        }
		
        if i32.eq(i, power-1) {
            str.print("Count of primes up to "+ commatize(power) + "10s = " + commatize(count))
            power *= 10
        }
    }
}

package main

func main() {
}
